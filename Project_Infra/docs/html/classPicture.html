<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Digital-Analysis-of-Fingerprints-MSIAM: Référence de la classe Picture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Digital-Analysis-of-Fingerprints-MSIAM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="classPicture-members.html">Liste de tous les membres</a>  </div>
  <div class="headertitle">
<div class="title">Référence de la classe Picture</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Picture_8h_source.html">Picture.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr class="memitem:aa397f9f6320a5fd36dd1f39844e659f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#aa397f9f6320a5fd36dd1f39844e659f2">Picture</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:aa397f9f6320a5fd36dd1f39844e659f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab203ea56b485f5113759fc516b23e1ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#ab203ea56b485f5113759fc516b23e1ff">Picture</a> (unsigned int x_length, unsigned int y_length)</td></tr>
<tr class="separator:ab203ea56b485f5113759fc516b23e1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99b9dfc57375bb6fcdfb70aba89cefc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#aa99b9dfc57375bb6fcdfb70aba89cefc">Picture</a> (const cv::Mat &amp;pic)</td></tr>
<tr class="separator:aa99b9dfc57375bb6fcdfb70aba89cefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8995e51ea021e90aaa42bb44a51d2b39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a8995e51ea021e90aaa42bb44a51d2b39">Picture</a> ()</td></tr>
<tr class="separator:a8995e51ea021e90aaa42bb44a51d2b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ef74e855f74fa7f13f730f5794d3b9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a73ef74e855f74fa7f13f730f5794d3b9">get_intensity</a> (unsigned int i, unsigned int j) const</td></tr>
<tr class="memdesc:a73ef74e855f74fa7f13f730f5794d3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which return the intensity of the pixel (j,i).  <a href="#a73ef74e855f74fa7f13f730f5794d3b9">Plus de détails...</a><br /></td></tr>
<tr class="separator:a73ef74e855f74fa7f13f730f5794d3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fc98e02fccbbe8c303dfb4f74ab70e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a49fc98e02fccbbe8c303dfb4f74ab70e">set_intensity</a> (unsigned int i, unsigned int j, float intensity)</td></tr>
<tr class="memdesc:a49fc98e02fccbbe8c303dfb4f74ab70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which set the intensity of the pixel (j,i).  <a href="#a49fc98e02fccbbe8c303dfb4f74ab70e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a49fc98e02fccbbe8c303dfb4f74ab70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2725aca45105195611b2926ee4426fb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a2725aca45105195611b2926ee4426fb3">operator=</a> (<a class="el" href="classPicture.html">Picture</a> pic)</td></tr>
<tr class="separator:a2725aca45105195611b2926ee4426fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ed16604156c378b7db6fdf8c576f1b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a62ed16604156c378b7db6fdf8c576f1b">get_x_len</a> () const</td></tr>
<tr class="memdesc:a62ed16604156c378b7db6fdf8c576f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which return the width of the image.  <a href="#a62ed16604156c378b7db6fdf8c576f1b">Plus de détails...</a><br /></td></tr>
<tr class="separator:a62ed16604156c378b7db6fdf8c576f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5585c15ca493068200cfb56e984ebd1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#af5585c15ca493068200cfb56e984ebd1">get_y_len</a> () const</td></tr>
<tr class="memdesc:af5585c15ca493068200cfb56e984ebd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which return the height of the image.  <a href="#af5585c15ca493068200cfb56e984ebd1">Plus de détails...</a><br /></td></tr>
<tr class="separator:af5585c15ca493068200cfb56e984ebd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca81009cad83739d2805e88726c6bf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#afca81009cad83739d2805e88726c6bf0">print_picture</a> () const</td></tr>
<tr class="memdesc:afca81009cad83739d2805e88726c6bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which print the <a class="el" href="classPicture.html">Picture</a>.  <a href="#afca81009cad83739d2805e88726c6bf0">Plus de détails...</a><br /></td></tr>
<tr class="separator:afca81009cad83739d2805e88726c6bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89fa0248ccd43f99bef6efd52c49c26"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#af89fa0248ccd43f99bef6efd52c49c26">maximum_intensity</a> () const</td></tr>
<tr class="memdesc:af89fa0248ccd43f99bef6efd52c49c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which return the maximum intensity of the image.  <a href="#af89fa0248ccd43f99bef6efd52c49c26">Plus de détails...</a><br /></td></tr>
<tr class="separator:af89fa0248ccd43f99bef6efd52c49c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3596ef7e0ad76f05817c7f1add908fc1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a3596ef7e0ad76f05817c7f1add908fc1">minimum_intensity</a> () const</td></tr>
<tr class="memdesc:a3596ef7e0ad76f05817c7f1add908fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which return the minimum intensity of the image.  <a href="#a3596ef7e0ad76f05817c7f1add908fc1">Plus de détails...</a><br /></td></tr>
<tr class="separator:a3596ef7e0ad76f05817c7f1add908fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa496dc958945a3f5470f7f661bdd8ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#aa496dc958945a3f5470f7f661bdd8ecd">symmetry_wrt_y</a> () const</td></tr>
<tr class="memdesc:aa496dc958945a3f5470f7f661bdd8ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which perform the symetry of the image along the Y axis.  <a href="#aa496dc958945a3f5470f7f661bdd8ecd">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa496dc958945a3f5470f7f661bdd8ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41f68bed9c7ddaf76e158dd1677d989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#ac41f68bed9c7ddaf76e158dd1677d989">symmetry_wrt_x</a> () const</td></tr>
<tr class="memdesc:ac41f68bed9c7ddaf76e158dd1677d989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which perform the symetry of the image along the X axis.  <a href="#ac41f68bed9c7ddaf76e158dd1677d989">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac41f68bed9c7ddaf76e158dd1677d989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41aa47eda2779a9514757ac1e13db0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a41aa47eda2779a9514757ac1e13db0a4">diagonal_symmetry_top_to_bottom</a> () const</td></tr>
<tr class="memdesc:a41aa47eda2779a9514757ac1e13db0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which perform the symetry of the image along the top to bottom diagonal.  <a href="#a41aa47eda2779a9514757ac1e13db0a4">Plus de détails...</a><br /></td></tr>
<tr class="separator:a41aa47eda2779a9514757ac1e13db0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5e76e986d14cb09d8ed863f18f3989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a1c5e76e986d14cb09d8ed863f18f3989">diagonal_symmetry_bottom_to_top</a> () const</td></tr>
<tr class="memdesc:a1c5e76e986d14cb09d8ed863f18f3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which perform the symetry of the image along the bottom to top diagonal.  <a href="#a1c5e76e986d14cb09d8ed863f18f3989">Plus de détails...</a><br /></td></tr>
<tr class="separator:a1c5e76e986d14cb09d8ed863f18f3989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582c106e75a698c6a821bac25239fa86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a582c106e75a698c6a821bac25239fa86">clone</a> () const</td></tr>
<tr class="memdesc:a582c106e75a698c6a821bac25239fa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a582c106e75a698c6a821bac25239fa86">Plus de détails...</a><br /></td></tr>
<tr class="separator:a582c106e75a698c6a821bac25239fa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e662e749180d0430107b9b2ff38a6d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a4e662e749180d0430107b9b2ff38a6d5">rescale_color</a> ()</td></tr>
<tr class="memdesc:a4e662e749180d0430107b9b2ff38a6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that rescale every color such that the maximum intensity is 1 and the minimum intensity is 0.  <a href="#a4e662e749180d0430107b9b2ff38a6d5">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4e662e749180d0430107b9b2ff38a6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf21e37ce0579362726801c0a827a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a4bf21e37ce0579362726801c0a827a19">SAVE_PIC</a> (std::string name) const</td></tr>
<tr class="memdesc:a4bf21e37ce0579362726801c0a827a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that save the picture as a .png.  <a href="#a4bf21e37ce0579362726801c0a827a19">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4bf21e37ce0579362726801c0a827a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7b4cfdb89bb15e70d4a430f846fb95"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; float, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#abe7b4cfdb89bb15e70d4a430f846fb95">get_matrix</a> () const</td></tr>
<tr class="memdesc:abe7b4cfdb89bb15e70d4a430f846fb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that return the matrix encoding the <a class="el" href="classPicture.html">Picture</a>.  <a href="#abe7b4cfdb89bb15e70d4a430f846fb95">Plus de détails...</a><br /></td></tr>
<tr class="separator:abe7b4cfdb89bb15e70d4a430f846fb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1338d21d62d1f8eb1523f50a5b8970"><td class="memItemLeft" align="right" valign="top">cv::Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a1c1338d21d62d1f8eb1523f50a5b8970">center_of_pressure</a> () const</td></tr>
<tr class="memdesc:a1c1338d21d62d1f8eb1523f50a5b8970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that compute the barycenter of the black pixel after a binary threshold.  <a href="#a1c1338d21d62d1f8eb1523f50a5b8970">Plus de détails...</a><br /></td></tr>
<tr class="separator:a1c1338d21d62d1f8eb1523f50a5b8970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52220698c6f8a2488e4231781be5ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#ab52220698c6f8a2488e4231781be5ca0">apply_gaussian_blur</a> (int win_size) const</td></tr>
<tr class="separator:ab52220698c6f8a2488e4231781be5ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934258ee27c9415ea797e0b527f734bc"><td class="memItemLeft" align="right" valign="top">cv::Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a934258ee27c9415ea797e0b527f734bc">get_index_minimum_intensity</a> () const</td></tr>
<tr class="separator:a934258ee27c9415ea797e0b527f734bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbada1eca07f4dd639acf20211879106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#acbada1eca07f4dd639acf20211879106">print_pression_center_gauss_threshold</a> ()</td></tr>
<tr class="separator:acbada1eca07f4dd639acf20211879106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2108d7dbc3c831791dc3d730f37c4d"><td class="memItemLeft" align="right" valign="top">cv::Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#aff2108d7dbc3c831791dc3d730f37c4d">pressure_center_gauss_threshold</a> () const</td></tr>
<tr class="separator:aff2108d7dbc3c831791dc3d730f37c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94645f7512db99e5cfc2255974fadf8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#af94645f7512db99e5cfc2255974fadf8">ellipse_nbh</a> (cv::Point p, unsigned int a, unsigned int b) const</td></tr>
<tr class="memdesc:af94645f7512db99e5cfc2255974fadf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an elliptical region on the image by checking whether or not the coordinates of each point satisfy a parametric equation.  <a href="#af94645f7512db99e5cfc2255974fadf8">Plus de détails...</a><br /></td></tr>
<tr class="separator:af94645f7512db99e5cfc2255974fadf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386c685f55ac781fd27031dbb5559d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a386c685f55ac781fd27031dbb5559d16">show_nbh</a> (std::vector&lt; cv::Point &gt; nbh) const</td></tr>
<tr class="memdesc:a386c685f55ac781fd27031dbb5559d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the elliptical region formed by the method "ellipse_nbh" as a white ellipse on the image. Could be used in general as a method to set any given set of pixels to white.  <a href="#a386c685f55ac781fd27031dbb5559d16">Plus de détails...</a><br /></td></tr>
<tr class="separator:a386c685f55ac781fd27031dbb5559d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b853d661dce7d90aa6621409ca0b87f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a3b853d661dce7d90aa6621409ca0b87f">apply_threshold</a> (float set_lim) const</td></tr>
<tr class="memdesc:a3b853d661dce7d90aa6621409ca0b87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that perform a threshold on the image.  <a href="#a3b853d661dce7d90aa6621409ca0b87f">Plus de détails...</a><br /></td></tr>
<tr class="separator:a3b853d661dce7d90aa6621409ca0b87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5ef449cf08855a726a4f24f2371d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a7e5ef449cf08855a726a4f24f2371d44">extract_ellipse_pic</a> (cv::Point &amp;center, unsigned int a, unsigned int b) const</td></tr>
<tr class="separator:a7e5ef449cf08855a726a4f24f2371d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46452d4d7564020ca40ceff61f3f7f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#ac46452d4d7564020ca40ceff61f3f7f7">transform_isotropic</a> (cv::Point p) const</td></tr>
<tr class="memdesc:ac46452d4d7564020ca40ceff61f3f7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that perform an isotropic intensity transformation on the image.  <a href="#ac46452d4d7564020ca40ceff61f3f7f7">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac46452d4d7564020ca40ceff61f3f7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2d01387798bfb803daaddc0ed61458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#aaf2d01387798bfb803daaddc0ed61458">transform_anisotropic</a> (cv::Point p, unsigned int a, unsigned int b) const</td></tr>
<tr class="memdesc:aaf2d01387798bfb803daaddc0ed61458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that perform an anisotropic intensity transformation on the image using an elliptic distance given with a center, and two radius.  <a href="#aaf2d01387798bfb803daaddc0ed61458">Plus de détails...</a><br /></td></tr>
<tr class="separator:aaf2d01387798bfb803daaddc0ed61458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f69fc5bc1febbd64af2995989399fc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a99f69fc5bc1febbd64af2995989399fc">weak_pressure_border</a> (cv::Point center, unsigned int a, unsigned int b) const</td></tr>
<tr class="memdesc:a99f69fc5bc1febbd64af2995989399fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that generate a random border around an ellipse.  <a href="#a99f69fc5bc1febbd64af2995989399fc">Plus de détails...</a><br /></td></tr>
<tr class="separator:a99f69fc5bc1febbd64af2995989399fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6c25c65fa207b866898af6a7d191be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a9c6c25c65fa207b866898af6a7d191be">weak_pressure_area</a> (std::vector&lt; cv::Point &gt; border, cv::Point center, unsigned int a, unsigned int b) const</td></tr>
<tr class="memdesc:a9c6c25c65fa207b866898af6a7d191be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that generate a random area around an ellipse.  <a href="#a9c6c25c65fa207b866898af6a7d191be">Plus de détails...</a><br /></td></tr>
<tr class="separator:a9c6c25c65fa207b866898af6a7d191be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cd733aa79110b1b4769b98c440a626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#aa0cd733aa79110b1b4769b98c440a626">attenuation_weak_area</a> (cv::Point center, unsigned int a, unsigned int b) const</td></tr>
<tr class="memdesc:aa0cd733aa79110b1b4769b98c440a626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that perform an anisotropic pixel transformation on a random area around an ellipse.  <a href="#aa0cd733aa79110b1b4769b98c440a626">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa0cd733aa79110b1b4769b98c440a626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746a5202273c9fe204a2dffd590c48d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a746a5202273c9fe204a2dffd590c48d0">isinframe</a> (cv::Point p) const</td></tr>
<tr class="memdesc:a746a5202273c9fe204a2dffd590c48d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a given pixel is within the frame of the image.  <a href="#a746a5202273c9fe204a2dffd590c48d0">Plus de détails...</a><br /></td></tr>
<tr class="separator:a746a5202273c9fe204a2dffd590c48d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbdb2a0df3155f6f5ef59f93dd66045"><td class="memItemLeft" align="right" valign="top">cv::Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#abdbdb2a0df3155f6f5ef59f93dd66045">local_cop</a> (std::list&lt; cv::Point &gt; &amp;region) const</td></tr>
<tr class="memdesc:abdbdb2a0df3155f6f5ef59f93dd66045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the barycentre - centre of pressure - of a local region of the image.  <a href="#abdbdb2a0df3155f6f5ef59f93dd66045">Plus de détails...</a><br /></td></tr>
<tr class="separator:abdbdb2a0df3155f6f5ef59f93dd66045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0187463518fc6c9c9ad73d1f565ee5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#adb0187463518fc6c9c9ad73d1f565ee5">local_cop_distance</a> (std::list&lt; cv::Point &gt; subset, cv::Point centre) const</td></tr>
<tr class="memdesc:adb0187463518fc6c9c9ad73d1f565ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the function "local_cop" and finds the Euclidean distance from the returned point to another point - the centre of rotation of the swirl. This method was written solely to be called by "swirl_zonalmorph".  <a href="#adb0187463518fc6c9c9ad73d1f565ee5">Plus de détails...</a><br /></td></tr>
<tr class="separator:adb0187463518fc6c9c9ad73d1f565ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3269976b9cc9a3d6aa536efeede017"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; std::list&lt; cv::Point &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#aca3269976b9cc9a3d6aa536efeede017">morph_subsets</a> (int radius, int subset_sidelen, cv::Point centre) const</td></tr>
<tr class="memdesc:aca3269976b9cc9a3d6aa536efeede017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a square around the area on which the swirl transformation is being applied and divides it into grid squares. This was written solely to be called by the method "swirl_zonalmorph".  <a href="#aca3269976b9cc9a3d6aa536efeede017">Plus de détails...</a><br /></td></tr>
<tr class="separator:aca3269976b9cc9a3d6aa536efeede017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5134f1cb4b71726fd87743c5e9053f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#aa5134f1cb4b71726fd87743c5e9053f1">cast_rotation_cart</a> (cv::Point centre, double angle) const</td></tr>
<tr class="memdesc:aa5134f1cb4b71726fd87743c5e9053f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that performs rotation of the pixel coordinates using a cartesian coordinate transformation then assigns intensities by casting the rotated co-ordinates to integers.  <a href="#aa5134f1cb4b71726fd87743c5e9053f1">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa5134f1cb4b71726fd87743c5e9053f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af74a4db9239da966f431ab6707910b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a3af74a4db9239da966f431ab6707910b">cast_rotation_polar</a> (cv::Point centre, double angle) const</td></tr>
<tr class="memdesc:a3af74a4db9239da966f431ab6707910b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that performs rotation of the pixel co-ordinates using conversion to polar co-ordinates then assigns intensities by casting the rotated co-ordinates to integers.  <a href="#a3af74a4db9239da966f431ab6707910b">Plus de détails...</a><br /></td></tr>
<tr class="separator:a3af74a4db9239da966f431ab6707910b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa72548de97134a61c589b56d1dad8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#acaa72548de97134a61c589b56d1dad8b">nn_rotation_polar</a> (cv::Point &amp;centre, double angle) const</td></tr>
<tr class="memdesc:acaa72548de97134a61c589b56d1dad8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that performs rotation of the pixel co-ordinates using conversion to polar co-ordinates then assigns intensities using nearest-neighbour interpolation; assigning to the new pixel the intensity of the original pixel with minimal Euclidean distance from it.  <a href="#acaa72548de97134a61c589b56d1dad8b">Plus de détails...</a><br /></td></tr>
<tr class="separator:acaa72548de97134a61c589b56d1dad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a7f95cf4afb267e8d5492afb8b0ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a65a7f95cf4afb267e8d5492afb8b0ab7">bilinear_rotation_polar</a> (cv::Point &amp;centre, double angle) const</td></tr>
<tr class="memdesc:a65a7f95cf4afb267e8d5492afb8b0ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that performs rotation of the pixel co-ordinates using conversion to polar co-ordinates then assigns intensities using bilinear interpolation; taking weighted sums of the surrounding pixels.  <a href="#a65a7f95cf4afb267e8d5492afb8b0ab7">Plus de détails...</a><br /></td></tr>
<tr class="separator:a65a7f95cf4afb267e8d5492afb8b0ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d27af85dc851842fcff8f001fac54d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a34d27af85dc851842fcff8f001fac54d">swirl</a> (cv::Point centre, double twist, int radius) const</td></tr>
<tr class="memdesc:a34d27af85dc851842fcff8f001fac54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that creates the swirl effect caused by rotating a finger under pressure in a similar way to the polar rotation functions except that in this case the angle is given as a function of the radial distance from the centre of rotation.  <a href="#a34d27af85dc851842fcff8f001fac54d">Plus de détails...</a><br /></td></tr>
<tr class="separator:a34d27af85dc851842fcff8f001fac54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6533ee45c6e423a3765a854c00eaefe"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#ad6533ee45c6e423a3765a854c00eaefe">bilinear_interpolation</a> (cv::Point2d p) const</td></tr>
<tr class="memdesc:ad6533ee45c6e423a3765a854c00eaefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointwise bilinear interpolation: more convenient for the swirl function implementation.  <a href="#ad6533ee45c6e423a3765a854c00eaefe">Plus de détails...</a><br /></td></tr>
<tr class="separator:ad6533ee45c6e423a3765a854c00eaefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2358613a2b65fca62dfc31844fb06a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#ade2358613a2b65fca62dfc31844fb06a">local_erosion</a> (cv::Point centre, int a, int b) const</td></tr>
<tr class="memdesc:ade2358613a2b65fca62dfc31844fb06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs morphological erosion on an elliptical region on the image.  <a href="#ade2358613a2b65fca62dfc31844fb06a">Plus de détails...</a><br /></td></tr>
<tr class="separator:ade2358613a2b65fca62dfc31844fb06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc3d23cdcabbba67f726f350bf80513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#abdc3d23cdcabbba67f726f350bf80513">local_dilation</a> (cv::Point centre, int a, int b) const</td></tr>
<tr class="memdesc:abdc3d23cdcabbba67f726f350bf80513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs morphological dilation on an elliptical region on the image.  <a href="#abdc3d23cdcabbba67f726f350bf80513">Plus de détails...</a><br /></td></tr>
<tr class="separator:abdc3d23cdcabbba67f726f350bf80513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb14ad715902c52f516c8c563ec8ddfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#abb14ad715902c52f516c8c563ec8ddfd">swirl_zonalmorph</a> (cv::Point centre, double twist, int radius, int root_num_sub) const</td></tr>
<tr class="memdesc:abb14ad715902c52f516c8c563ec8ddfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the swirl transform followed by localised morphological filtering depending on the relative position of the barycentre of each list of Point objects returned by the function "morph_subsets".  <a href="#abb14ad715902c52f516c8c563ec8ddfd">Plus de détails...</a><br /></td></tr>
<tr class="separator:abb14ad715902c52f516c8c563ec8ddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47ba6127dd18f12fc46da84ba00fe08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#ab47ba6127dd18f12fc46da84ba00fe08">discrete_convolution</a> (Eigen::Matrix&lt; float, Eigen::Dynamic, Eigen::Dynamic &gt; mask) const</td></tr>
<tr class="memdesc:ab47ba6127dd18f12fc46da84ba00fe08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that perform a discrete convolution between a <a class="el" href="classPicture.html">Picture</a> and a mask.  <a href="#ab47ba6127dd18f12fc46da84ba00fe08">Plus de détails...</a><br /></td></tr>
<tr class="separator:ab47ba6127dd18f12fc46da84ba00fe08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce89a3c0a5bd8af9cf83125e16e7bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#adce89a3c0a5bd8af9cf83125e16e7bb8">ConvolutionDFT</a> (Eigen::Matrix&lt; float, Eigen::Dynamic, Eigen::Dynamic &gt; mask) const</td></tr>
<tr class="memdesc:adce89a3c0a5bd8af9cf83125e16e7bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that perform a discrete convolution between a <a class="el" href="classPicture.html">Picture</a> and a mask using Fast Fourrier Transform.  <a href="#adce89a3c0a5bd8af9cf83125e16e7bb8">Plus de détails...</a><br /></td></tr>
<tr class="separator:adce89a3c0a5bd8af9cf83125e16e7bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fe29a7da463b8c8ef56bba17e805de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a51fe29a7da463b8c8ef56bba17e805de">discrete_convolution_evolutive_kernel</a> () const</td></tr>
<tr class="memdesc:a51fe29a7da463b8c8ef56bba17e805de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that perform a discrete convolution between a <a class="el" href="classPicture.html">Picture</a> and an evolutive preset mask (given by the function Evolutive_kernel).  <a href="#a51fe29a7da463b8c8ef56bba17e805de">Plus de détails...</a><br /></td></tr>
<tr class="separator:a51fe29a7da463b8c8ef56bba17e805de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ea55b0c8ebc6a1eb1674f3f41bc483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a01ea55b0c8ebc6a1eb1674f3f41bc483">discrete_convolution_evolutive_kernel_no_identity</a> () const</td></tr>
<tr class="memdesc:a01ea55b0c8ebc6a1eb1674f3f41bc483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that perform a discrete convolution between a <a class="el" href="classPicture.html">Picture</a> and an evolutive preset mask (given by the function Evolutive_kernel_no_identity).  <a href="#a01ea55b0c8ebc6a1eb1674f3f41bc483">Plus de détails...</a><br /></td></tr>
<tr class="separator:a01ea55b0c8ebc6a1eb1674f3f41bc483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3de826b7693f687b760d4ed8246f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a8a3de826b7693f687b760d4ed8246f40">translation_x</a> (int coeff) const</td></tr>
<tr class="memdesc:a8a3de826b7693f687b760d4ed8246f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which perform picture translation along x.  <a href="#a8a3de826b7693f687b760d4ed8246f40">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8a3de826b7693f687b760d4ed8246f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92edfcd1b92afc6fd9fa658bcb59f423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a92edfcd1b92afc6fd9fa658bcb59f423">translation_y</a> (int coeff) const</td></tr>
<tr class="memdesc:a92edfcd1b92afc6fd9fa658bcb59f423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which perform picture translation along y.  <a href="#a92edfcd1b92afc6fd9fa658bcb59f423">Plus de détails...</a><br /></td></tr>
<tr class="separator:a92edfcd1b92afc6fd9fa658bcb59f423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cadad4cac27c77812e528964f00576"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#aa6cadad4cac27c77812e528964f00576">is_same</a> (<a class="el" href="classPicture.html">Picture</a> &amp;image) const</td></tr>
<tr class="memdesc:aa6cadad4cac27c77812e528964f00576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction which test if two pictures are the same.  <a href="#aa6cadad4cac27c77812e528964f00576">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa6cadad4cac27c77812e528964f00576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72461986d10417b66850e32c25c20751"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a72461986d10417b66850e32c25c20751">error</a> (<a class="el" href="classPicture.html">Picture</a> &amp;image) const</td></tr>
<tr class="memdesc:a72461986d10417b66850e32c25c20751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction which compute the squared error between two pictures.  <a href="#a72461986d10417b66850e32c25c20751">Plus de détails...</a><br /></td></tr>
<tr class="separator:a72461986d10417b66850e32c25c20751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70683bd364d34047758d3ccf2f6178f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#ac70683bd364d34047758d3ccf2f6178f">print_loss_function_x_translation</a> (<a class="el" href="classPicture.html">Picture</a> &amp;translated) const</td></tr>
<tr class="memdesc:ac70683bd364d34047758d3ccf2f6178f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performing the Bruteforce estimation of the translation parameter along x axis with squared error.  <a href="#ac70683bd364d34047758d3ccf2f6178f">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac70683bd364d34047758d3ccf2f6178f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483b15adb1fb60952a4b0d78b7032952"><td class="memItemLeft" align="right" valign="top">cv::Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a483b15adb1fb60952a4b0d78b7032952">print_loss_function_xy_translation</a> (<a class="el" href="classPicture.html">Picture</a> &amp;translated) const</td></tr>
<tr class="memdesc:a483b15adb1fb60952a4b0d78b7032952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performing the Bruteforce estimation of the translations parameters along x and y axis with squared error (take approximatelly 10 min).  <a href="#a483b15adb1fb60952a4b0d78b7032952">Plus de détails...</a><br /></td></tr>
<tr class="separator:a483b15adb1fb60952a4b0d78b7032952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3c0a19d314e537fa02b32b753d1b2e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a1f3c0a19d314e537fa02b32b753d1b2e">loss_function_xt_by_barycenter</a> (<a class="el" href="classPicture.html">Picture</a> &amp;translated) const</td></tr>
<tr class="memdesc:a1f3c0a19d314e537fa02b32b753d1b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performing a rapid estimation of the translation parameter along x axis by comparing the two barycenters with squared error.  <a href="#a1f3c0a19d314e537fa02b32b753d1b2e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a1f3c0a19d314e537fa02b32b753d1b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c35a3efdb131d758669d4ee6c97363"><td class="memItemLeft" align="right" valign="top">cv::Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#ad9c35a3efdb131d758669d4ee6c97363">loss_function_xyt_by_barycenter</a> (<a class="el" href="classPicture.html">Picture</a> &amp;translated) const</td></tr>
<tr class="memdesc:ad9c35a3efdb131d758669d4ee6c97363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performing a rapid estimation of the translation parameters along x and y axis by comparing the two barycenters with squared error.  <a href="#ad9c35a3efdb131d758669d4ee6c97363">Plus de détails...</a><br /></td></tr>
<tr class="separator:ad9c35a3efdb131d758669d4ee6c97363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfad20390ce78d52fe6c58f23cc02419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#acfad20390ce78d52fe6c58f23cc02419">operator-</a> (<a class="el" href="classPicture.html">Picture</a> to_substract) const</td></tr>
<tr class="memdesc:acfad20390ce78d52fe6c58f23cc02419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator - is overloaded in order to give us the absolute error picture. If the result is a black picture then both pictures that were compared were the same.  <a href="#acfad20390ce78d52fe6c58f23cc02419">Plus de détails...</a><br /></td></tr>
<tr class="separator:acfad20390ce78d52fe6c58f23cc02419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175a18c2bc64b444165451c0e372cde0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a175a18c2bc64b444165451c0e372cde0">error_covariance_like</a> (<a class="el" href="classPicture.html">Picture</a> &amp;image) const</td></tr>
<tr class="memdesc:a175a18c2bc64b444165451c0e372cde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction which compute the 2nd loss function between two pictures.  <a href="#a175a18c2bc64b444165451c0e372cde0">Plus de détails...</a><br /></td></tr>
<tr class="separator:a175a18c2bc64b444165451c0e372cde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af984b6b082be59e5034a0b370335acdc"><td class="memItemLeft" align="right" valign="top">cv::Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#af984b6b082be59e5034a0b370335acdc">loss_function_xyt_by_barycenter_covariance_error</a> (<a class="el" href="classPicture.html">Picture</a> &amp;translated) const</td></tr>
<tr class="memdesc:af984b6b082be59e5034a0b370335acdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performing a rapid estimation of the translation parameters along x and y axis by comparing the two barycenters with 2nd loss function.  <a href="#af984b6b082be59e5034a0b370335acdc">Plus de détails...</a><br /></td></tr>
<tr class="separator:af984b6b082be59e5034a0b370335acdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199f9e1e28a3b546e632c53159512bc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a199f9e1e28a3b546e632c53159512bc7">floating_translation</a> (float x, float y) const</td></tr>
<tr class="memdesc:a199f9e1e28a3b546e632c53159512bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which allow us to perform translation with floating param.  <a href="#a199f9e1e28a3b546e632c53159512bc7">Plus de détails...</a><br /></td></tr>
<tr class="separator:a199f9e1e28a3b546e632c53159512bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f32f102f691a00b5f11849c2e98c0e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#ad3f32f102f691a00b5f11849c2e98c0e">find_opti_px</a> (float aproxim, <a class="el" href="classPicture.html">Picture</a> &amp;translated) const</td></tr>
<tr class="memdesc:ad3f32f102f691a00b5f11849c2e98c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which allow us find a more accurate translation parameter along x axis given the closest integer approximating shift param.  <a href="#ad3f32f102f691a00b5f11849c2e98c0e">Plus de détails...</a><br /></td></tr>
<tr class="separator:ad3f32f102f691a00b5f11849c2e98c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2447697977055475a5f67fa2e0cfe066"><td class="memItemLeft" align="right" valign="top">cv::Point2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a2447697977055475a5f67fa2e0cfe066">find_opti_px_py</a> (cv::Point_&lt; float &gt; aproxim, <a class="el" href="classPicture.html">Picture</a> &amp;translated) const</td></tr>
<tr class="memdesc:a2447697977055475a5f67fa2e0cfe066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which allow us find more accurate translation parameters along x and y axis given the closest integer approximating shift param.  <a href="#a2447697977055475a5f67fa2e0cfe066">Plus de détails...</a><br /></td></tr>
<tr class="separator:a2447697977055475a5f67fa2e0cfe066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351efc5be98e393cee2711b97a017404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a351efc5be98e393cee2711b97a017404">translation_opti_int_xy</a> (int x, int y) const</td></tr>
<tr class="memdesc:a351efc5be98e393cee2711b97a017404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which allow us to perform a fast translation with integer param.  <a href="#a351efc5be98e393cee2711b97a017404">Plus de détails...</a><br /></td></tr>
<tr class="separator:a351efc5be98e393cee2711b97a017404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d1eee465e67d3094dd61bdaad5aa46"><td class="memItemLeft" align="right" valign="top">cv::Point2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#ac3d1eee465e67d3094dd61bdaad5aa46">estimation_tranlsation_by_dft</a> (<a class="el" href="classPicture.html">Picture</a> &amp;translated) const</td></tr>
<tr class="memdesc:ac3d1eee465e67d3094dd61bdaad5aa46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which approximate translations parameters along x and y axis using discrete Fourier transform.  <a href="#ac3d1eee465e67d3094dd61bdaad5aa46">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac3d1eee465e67d3094dd61bdaad5aa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140d973f71d0e3cce52b6e56b4645050"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a140d973f71d0e3cce52b6e56b4645050">estimation_rotation_bruteforce</a> (<a class="el" href="classPicture.html">Picture</a> &amp;rotated) const</td></tr>
<tr class="memdesc:a140d973f71d0e3cce52b6e56b4645050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performing the Bruteforce estimation of the rotation parameters with squared error.  <a href="#a140d973f71d0e3cce52b6e56b4645050">Plus de détails...</a><br /></td></tr>
<tr class="separator:a140d973f71d0e3cce52b6e56b4645050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f07f674b2ceaacdde38bb4b5a273bb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a76f07f674b2ceaacdde38bb4b5a273bb">more_accurate_rotation_parameter</a> (float angle, <a class="el" href="classPicture.html">Picture</a> &amp;rotated) const</td></tr>
<tr class="memdesc:a76f07f674b2ceaacdde38bb4b5a273bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which allow us to accurate the rotation parameter with squared error.  <a href="#a76f07f674b2ceaacdde38bb4b5a273bb">Plus de détails...</a><br /></td></tr>
<tr class="separator:a76f07f674b2ceaacdde38bb4b5a273bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0b7c2f2b64317c06dfba0e924fa470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPicture.html">Picture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#adb0b7c2f2b64317c06dfba0e924fa470">put_barycenter_at_picture_center</a> () const</td></tr>
<tr class="memdesc:adb0b7c2f2b64317c06dfba0e924fa470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function translate the picture in order to put the barycenter of the picture at the center of the picture.  <a href="#adb0b7c2f2b64317c06dfba0e924fa470">Plus de détails...</a><br /></td></tr>
<tr class="separator:adb0b7c2f2b64317c06dfba0e924fa470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa888d4e8dee3200cc17b471626e65b88"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#aa888d4e8dee3200cc17b471626e65b88">sum_intensity_picture</a> () const</td></tr>
<tr class="memdesc:aa888d4e8dee3200cc17b471626e65b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which compute the sum of the pixels intensity of a picture.  <a href="#aa888d4e8dee3200cc17b471626e65b88">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa888d4e8dee3200cc17b471626e65b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0edcdd4636ba48f8a06a4c393828c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a5f0edcdd4636ba48f8a06a4c393828c6">execution_evaluation_rtxy</a> (<a class="el" href="classPicture.html">Picture</a> &amp;Rot_txy_picture) const</td></tr>
<tr class="memdesc:a5f0edcdd4636ba48f8a06a4c393828c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which compute the closest interger to rotation parameter and the two floating points which approximate the translation parameterS between two pictures.  <a href="#a5f0edcdd4636ba48f8a06a4c393828c6">Plus de détails...</a><br /></td></tr>
<tr class="separator:a5f0edcdd4636ba48f8a06a4c393828c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e7b8b1b9fcd96c03abead9e37e4fe3"><td class="memItemLeft" align="right" valign="top">float **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a38e7b8b1b9fcd96c03abead9e37e4fe3">dg_dwx</a> () const</td></tr>
<tr class="memdesc:a38e7b8b1b9fcd96c03abead9e37e4fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the partial derivative of the picture along x axis (finite difference scheme)  <a href="#a38e7b8b1b9fcd96c03abead9e37e4fe3">Plus de détails...</a><br /></td></tr>
<tr class="separator:a38e7b8b1b9fcd96c03abead9e37e4fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4deff767aa2d1e136129b33832fda51e"><td class="memItemLeft" align="right" valign="top">float **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a4deff767aa2d1e136129b33832fda51e">dg_dwy</a> () const</td></tr>
<tr class="memdesc:a4deff767aa2d1e136129b33832fda51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the partial derivative of the picture along y axis (finite difference scheme)  <a href="#a4deff767aa2d1e136129b33832fda51e">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4deff767aa2d1e136129b33832fda51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a1616872105072c7d48a4a9dc74df5"><td class="memItemLeft" align="right" valign="top">cv::Point2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a15a1616872105072c7d48a4a9dc74df5">Error_partial_deriv_px_py</a> (cv::Point2f p_after, <a class="el" href="classPicture.html">Picture</a> &amp;translated) const</td></tr>
<tr class="memdesc:a15a1616872105072c7d48a4a9dc74df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Gradient of the squared error loss function.  <a href="#a15a1616872105072c7d48a4a9dc74df5">Plus de détails...</a><br /></td></tr>
<tr class="separator:a15a1616872105072c7d48a4a9dc74df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1716f980778f89cb9ad02c2ace0b16f8"><td class="memItemLeft" align="right" valign="top">cv::Point2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPicture.html#a1716f980778f89cb9ad02c2ace0b16f8">gradient_descent</a> (cv::Point2f p_after, float epsilon, float alpha, <a class="el" href="classPicture.html">Picture</a> &amp;translated) const</td></tr>
<tr class="memdesc:a1716f980778f89cb9ad02c2ace0b16f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the translation param between two pictures with the gradient descent method. Only works if |px|+|py|&lt;=3. Better results if both of them are positives.  <a href="#a1716f980778f89cb9ad02c2ace0b16f8">Plus de détails...</a><br /></td></tr>
<tr class="separator:a1716f980778f89cb9ad02c2ace0b16f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Documentation des constructeurs et destructeur</h2>
<a id="aa397f9f6320a5fd36dd1f39844e659f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa397f9f6320a5fd36dd1f39844e659f2">&#9670;&nbsp;</a></span>Picture() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Picture::Picture </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab203ea56b485f5113759fc516b23e1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab203ea56b485f5113759fc516b23e1ff">&#9670;&nbsp;</a></span>Picture() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Picture::Picture </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>y_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa99b9dfc57375bb6fcdfb70aba89cefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99b9dfc57375bb6fcdfb70aba89cefc">&#9670;&nbsp;</a></span>Picture() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Picture::Picture </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>pic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8995e51ea021e90aaa42bb44a51d2b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8995e51ea021e90aaa42bb44a51d2b39">&#9670;&nbsp;</a></span>Picture() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Picture::Picture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Documentation des fonctions membres</h2>
<a id="ab52220698c6f8a2488e4231781be5ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52220698c6f8a2488e4231781be5ca0">&#9670;&nbsp;</a></span>apply_gaussian_blur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::apply_gaussian_blur </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>win_size</em> = <code>5</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b853d661dce7d90aa6621409ca0b87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b853d661dce7d90aa6621409ca0b87f">&#9670;&nbsp;</a></span>apply_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::apply_threshold </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>set_lim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that perform a threshold on the image. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">set_lim</td><td>The threshold coefficient (float in [0,1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The transformed <a class="el" href="classPicture.html">Picture</a>. </dd></dl>

</div>
</div>
<a id="aa0cd733aa79110b1b4769b98c440a626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cd733aa79110b1b4769b98c440a626">&#9670;&nbsp;</a></span>attenuation_weak_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::attenuation_weak_area </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that perform an anisotropic pixel transformation on a random area around an ellipse. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The center of the ellipse. </td></tr>
    <tr><td class="paramname">a</td><td>the small radius of the ellipse. </td></tr>
    <tr><td class="paramname">b</td><td>the big radius of the ellipse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The transformed <a class="el" href="classPicture.html">Picture</a> </dd></dl>

</div>
</div>
<a id="ad6533ee45c6e423a3765a854c00eaefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6533ee45c6e423a3765a854c00eaefe">&#9670;&nbsp;</a></span>bilinear_interpolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::bilinear_interpolation </td>
          <td>(</td>
          <td class="paramtype">cv::Point2d&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointwise bilinear interpolation: more convenient for the swirl function implementation. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Point object (with double-precision floating point coordinates) to be interpolated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Intensity value resulting from the interpolation. </dd></dl>

</div>
</div>
<a id="a65a7f95cf4afb267e8d5492afb8b0ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a7f95cf4afb267e8d5492afb8b0ab7">&#9670;&nbsp;</a></span>bilinear_rotation_polar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::bilinear_rotation_polar </td>
          <td>(</td>
          <td class="paramtype">cv::Point &amp;&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that performs rotation of the pixel co-ordinates using conversion to polar co-ordinates then assigns intensities using bilinear interpolation; taking weighted sums of the surrounding pixels. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">centre</td><td>The centre of rotation as a Point object </td></tr>
    <tr><td class="paramname">angle</td><td>The angle of rotation in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>A new <a class="el" href="classPicture.html">Picture</a> object with the rotated intensity values. </dd></dl>

</div>
</div>
<a id="aa5134f1cb4b71726fd87743c5e9053f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5134f1cb4b71726fd87743c5e9053f1">&#9670;&nbsp;</a></span>cast_rotation_cart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::cast_rotation_cart </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method that performs rotation of the pixel coordinates using a cartesian coordinate transformation then assigns intensities by casting the rotated co-ordinates to integers. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">centre</td><td>the centre of rotation as a Point object </td></tr>
    <tr><td class="paramname">angle</td><td>The angle of rotation in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>A new <a class="el" href="classPicture.html">Picture</a> object with the rotated intensity values. </dd></dl>

</div>
</div>
<a id="a3af74a4db9239da966f431ab6707910b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af74a4db9239da966f431ab6707910b">&#9670;&nbsp;</a></span>cast_rotation_polar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::cast_rotation_polar </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method that performs rotation of the pixel co-ordinates using conversion to polar co-ordinates then assigns intensities by casting the rotated co-ordinates to integers. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">centre</td><td>the centre of rotation as a Point object </td></tr>
    <tr><td class="paramname">angle</td><td>The angle of rotation in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>A new <a class="el" href="classPicture.html">Picture</a> object with the rotated intensity values. </dd></dl>

</div>
</div>
<a id="a1c1338d21d62d1f8eb1523f50a5b8970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1338d21d62d1f8eb1523f50a5b8970">&#9670;&nbsp;</a></span>center_of_pressure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point Picture::center_of_pressure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that compute the barycenter of the black pixel after a binary threshold. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The barycenter of the <a class="el" href="classPicture.html">Picture</a>. </dd></dl>

</div>
</div>
<a id="a582c106e75a698c6a821bac25239fa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582c106e75a698c6a821bac25239fa86">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>A copy of the <a class="el" href="classPicture.html">Picture</a> (type <a class="el" href="classPicture.html">Picture</a>). </dd></dl>

</div>
</div>
<a id="adce89a3c0a5bd8af9cf83125e16e7bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce89a3c0a5bd8af9cf83125e16e7bb8">&#9670;&nbsp;</a></span>ConvolutionDFT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::ConvolutionDFT </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; float, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that perform a discrete convolution between a <a class="el" href="classPicture.html">Picture</a> and a mask using Fast Fourrier Transform. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>the eigen matrix of the mask that will be convolved with the picture (type: Matrix&lt;float,Dynamic,Dynamic&gt;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The result <a class="el" href="classPicture.html">Picture</a> of the convolution. </dd></dl>

</div>
</div>
<a id="a38e7b8b1b9fcd96c03abead9e37e4fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e7b8b1b9fcd96c03abead9e37e4fe3">&#9670;&nbsp;</a></span>dg_dwx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ** Picture::dg_dwx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and return the partial derivative of the picture along x axis (finite difference scheme) </p>
<p>return The 2D matrix containing the intensities </p>

</div>
</div>
<a id="a4deff767aa2d1e136129b33832fda51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4deff767aa2d1e136129b33832fda51e">&#9670;&nbsp;</a></span>dg_dwy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ** Picture::dg_dwy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute and return the partial derivative of the picture along y axis (finite difference scheme) </p>
<p>return The 2D matrix containing the intensities </p>

</div>
</div>
<a id="a1c5e76e986d14cb09d8ed863f18f3989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5e76e986d14cb09d8ed863f18f3989">&#9670;&nbsp;</a></span>diagonal_symmetry_bottom_to_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::diagonal_symmetry_bottom_to_top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which perform the symetry of the image along the bottom to top diagonal. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The transformed <a class="el" href="classPicture.html">Picture</a> (type <a class="el" href="classPicture.html">Picture</a>). </dd></dl>

</div>
</div>
<a id="a41aa47eda2779a9514757ac1e13db0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41aa47eda2779a9514757ac1e13db0a4">&#9670;&nbsp;</a></span>diagonal_symmetry_top_to_bottom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::diagonal_symmetry_top_to_bottom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which perform the symetry of the image along the top to bottom diagonal. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The transformed <a class="el" href="classPicture.html">Picture</a> (type <a class="el" href="classPicture.html">Picture</a>). </dd></dl>

</div>
</div>
<a id="ab47ba6127dd18f12fc46da84ba00fe08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47ba6127dd18f12fc46da84ba00fe08">&#9670;&nbsp;</a></span>discrete_convolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::discrete_convolution </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; float, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that perform a discrete convolution between a <a class="el" href="classPicture.html">Picture</a> and a mask. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>the eigen matrix of the mask that will be convolved with the picture (type: Matrix&lt;float,Dynamic,Dynamic&gt;). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The result <a class="el" href="classPicture.html">Picture</a> of the convolution. </dd></dl>

</div>
</div>
<a id="a51fe29a7da463b8c8ef56bba17e805de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fe29a7da463b8c8ef56bba17e805de">&#9670;&nbsp;</a></span>discrete_convolution_evolutive_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::discrete_convolution_evolutive_kernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that perform a discrete convolution between a <a class="el" href="classPicture.html">Picture</a> and an evolutive preset mask (given by the function Evolutive_kernel). </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The result <a class="el" href="classPicture.html">Picture</a> of the convolution. </dd></dl>

</div>
</div>
<a id="a01ea55b0c8ebc6a1eb1674f3f41bc483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ea55b0c8ebc6a1eb1674f3f41bc483">&#9670;&nbsp;</a></span>discrete_convolution_evolutive_kernel_no_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::discrete_convolution_evolutive_kernel_no_identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that perform a discrete convolution between a <a class="el" href="classPicture.html">Picture</a> and an evolutive preset mask (given by the function Evolutive_kernel_no_identity). </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The result <a class="el" href="classPicture.html">Picture</a> of the convolution. </dd></dl>

</div>
</div>
<a id="af94645f7512db99e5cfc2255974fadf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94645f7512db99e5cfc2255974fadf8">&#9670;&nbsp;</a></span>ellipse_nbh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; Point &gt; Picture::ellipse_nbh </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an elliptical region on the image by checking whether or not the coordinates of each point satisfy a parametric equation. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Point object for the centre of the ellipse and integers for the major and minor axes </td></tr>
    <tr><td class="paramname">a</td><td>minor axis of the ellipse </td></tr>
    <tr><td class="paramname">b</td><td>major axis of the ellipse</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>vector of Point objects corresponding to the elliptical region </dd></dl>

</div>
</div>
<a id="a72461986d10417b66850e32c25c20751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72461986d10417b66850e32c25c20751">&#9670;&nbsp;</a></span>error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction which compute the squared error between two pictures. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the picture you want to be compared with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The squared error between the two pictures. </dd></dl>

</div>
</div>
<a id="a175a18c2bc64b444165451c0e372cde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175a18c2bc64b444165451c0e372cde0">&#9670;&nbsp;</a></span>error_covariance_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::error_covariance_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction which compute the 2nd loss function between two pictures. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the picture you want to be compared with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The error between the two pictures - float. </dd></dl>

</div>
</div>
<a id="a15a1616872105072c7d48a4a9dc74df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a1616872105072c7d48a4a9dc74df5">&#9670;&nbsp;</a></span>Error_partial_deriv_px_py()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point2f Picture::Error_partial_deriv_px_py </td>
          <td>(</td>
          <td class="paramtype">cv::Point2f&#160;</td>
          <td class="paramname"><em>p_after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>translated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Gradient of the squared error loss function. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_after</td><td>Translation param </td></tr>
    <tr><td class="paramname">translated</td><td>translated picture of which we are looking for translation parameters</td></tr>
  </table>
  </dd>
</dl>
<p>return The gradient of the loss function </p>

</div>
</div>
<a id="a140d973f71d0e3cce52b6e56b4645050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140d973f71d0e3cce52b6e56b4645050">&#9670;&nbsp;</a></span>estimation_rotation_bruteforce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::estimation_rotation_bruteforce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>rotated</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performing the Bruteforce estimation of the rotation parameters with squared error. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotated</td><td>the rotated picture</td></tr>
  </table>
  </dd>
</dl>
<p>return The closest integer to the rotation parameter between the two pictures </p>

</div>
</div>
<a id="ac3d1eee465e67d3094dd61bdaad5aa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d1eee465e67d3094dd61bdaad5aa46">&#9670;&nbsp;</a></span>estimation_tranlsation_by_dft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point2f Picture::estimation_tranlsation_by_dft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>translated</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which approximate translations parameters along x and y axis using discrete Fourier transform. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">translated</td><td>the translated picture</td></tr>
  </table>
  </dd>
</dl>
<p>return The floating translation parameters which minimize the squared error between the two pictures </p>

</div>
</div>
<a id="a5f0edcdd4636ba48f8a06a4c393828c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0edcdd4636ba48f8a06a4c393828c6">&#9670;&nbsp;</a></span>execution_evaluation_rtxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picture::execution_evaluation_rtxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>Rot_txy_picture</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which compute the closest interger to rotation parameter and the two floating points which approximate the translation parameterS between two pictures. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">Rot_txy_picture</td><td>the rotated and translated picture.</td></tr>
  </table>
  </dd>
</dl>
<p>return NONE </p>

</div>
</div>
<a id="a7e5ef449cf08855a726a4f24f2371d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5ef449cf08855a726a4f24f2371d44">&#9670;&nbsp;</a></span>extract_ellipse_pic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::extract_ellipse_pic </td>
          <td>(</td>
          <td class="paramtype">cv::Point &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3f32f102f691a00b5f11849c2e98c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f32f102f691a00b5f11849c2e98c0e">&#9670;&nbsp;</a></span>find_opti_px()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::find_opti_px </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aproxim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>translated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which allow us find a more accurate translation parameter along x axis given the closest integer approximating shift param. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">aproxim</td><td>the return of one of the function loss_function_xt_by_barycenter or print_loss_function_x_translation. </td></tr>
    <tr><td class="paramname">translated</td><td>the translated picture. return The floating translation parameter which minimize the error between the two pictures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2447697977055475a5f67fa2e0cfe066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2447697977055475a5f67fa2e0cfe066">&#9670;&nbsp;</a></span>find_opti_px_py()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point2f Picture::find_opti_px_py </td>
          <td>(</td>
          <td class="paramtype">cv::Point_&lt; float &gt;&#160;</td>
          <td class="paramname"><em>aproxim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>translated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which allow us find more accurate translation parameters along x and y axis given the closest integer approximating shift param. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">aproxim</td><td>the returned param of one of the function loss_function_xt_by_barycenter or print_loss_function_x_translation. </td></tr>
    <tr><td class="paramname">translated</td><td>the translated picture. return The floating translation parameters which minimizes the error between the two pictures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a199f9e1e28a3b546e632c53159512bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199f9e1e28a3b546e632c53159512bc7">&#9670;&nbsp;</a></span>floating_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::floating_translation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which allow us to perform translation with floating param. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>floating shift parameter along x axis. </td></tr>
    <tr><td class="paramname">y</td><td>floating shift parameter along y axis. return The translated picture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a934258ee27c9415ea797e0b527f734bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934258ee27c9415ea797e0b527f734bc">&#9670;&nbsp;</a></span>get_index_minimum_intensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point Picture::get_index_minimum_intensity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73ef74e855f74fa7f13f730f5794d3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ef74e855f74fa7f13f730f5794d3b9">&#9670;&nbsp;</a></span>get_intensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::get_intensity </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which return the intensity of the pixel (j,i). </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>of the coordinates (i,j) of the pixel. </td></tr>
    <tr><td class="paramname">j</td><td>of the coordinate (i,j) of the pixel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The intensity of the pixel (j,i). </dd></dl>

</div>
</div>
<a id="abe7b4cfdb89bb15e70d4a430f846fb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7b4cfdb89bb15e70d4a430f846fb95">&#9670;&nbsp;</a></span>get_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; float, Dynamic, Dynamic &gt; Picture::get_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that return the matrix encoding the <a class="el" href="classPicture.html">Picture</a>. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>An Eigen Matrix encoding the <a class="el" href="classPicture.html">Picture</a> (type: Matrix&lt;float,Dynamic,Dynamic&gt;). </dd></dl>

</div>
</div>
<a id="a62ed16604156c378b7db6fdf8c576f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ed16604156c378b7db6fdf8c576f1b">&#9670;&nbsp;</a></span>get_x_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Picture::get_x_len </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which return the width of the image. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Width of the image (unsigned int). </dd></dl>

</div>
</div>
<a id="af5585c15ca493068200cfb56e984ebd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5585c15ca493068200cfb56e984ebd1">&#9670;&nbsp;</a></span>get_y_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Picture::get_y_len </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which return the height of the image. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Height of the image (unsigned int). </dd></dl>

</div>
</div>
<a id="a1716f980778f89cb9ad02c2ace0b16f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1716f980778f89cb9ad02c2ace0b16f8">&#9670;&nbsp;</a></span>gradient_descent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point2f Picture::gradient_descent </td>
          <td>(</td>
          <td class="paramtype">cv::Point2f&#160;</td>
          <td class="paramname"><em>p_after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>translated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the translation param between two pictures with the gradient descent method. Only works if |px|+|py|&lt;=3. Better results if both of them are positives. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_after</td><td>translation param </td></tr>
    <tr><td class="paramname">epsilon</td><td>stop condition </td></tr>
    <tr><td class="paramname">alpha</td><td></td></tr>
    <tr><td class="paramname">translated</td><td>the shifted picture of which we are looking for translation parameters</td></tr>
  </table>
  </dd>
</dl>
<p>return The gradient of the loss function </p>

</div>
</div>
<a id="aa6cadad4cac27c77812e528964f00576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cadad4cac27c77812e528964f00576">&#9670;&nbsp;</a></span>is_same()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Picture::is_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction which test if two pictures are the same. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the picture you want to be compared with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>True if the two pictures are the same, False otherwise. </dd></dl>

</div>
</div>
<a id="a746a5202273c9fe204a2dffd590c48d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746a5202273c9fe204a2dffd590c48d0">&#9670;&nbsp;</a></span>isinframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Picture::isinframe </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a given pixel is within the frame of the image. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Point object (integer coordinates).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Boolean: true if the point is within the frame, false if not. </dd></dl>

</div>
</div>
<a id="abdbdb2a0df3155f6f5ef59f93dd66045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbdb2a0df3155f6f5ef59f93dd66045">&#9670;&nbsp;</a></span>local_cop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point Picture::local_cop </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; cv::Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the barycentre - centre of pressure - of a local region of the image. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>A list of the pixels contained in the region - Point objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Point object representing the centre of pressure. </dd></dl>

</div>
</div>
<a id="adb0187463518fc6c9c9ad73d1f565ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0187463518fc6c9c9ad73d1f565ee5">&#9670;&nbsp;</a></span>local_cop_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Picture::local_cop_distance </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; cv::Point &gt;&#160;</td>
          <td class="paramname"><em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>centre</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the function "local_cop" and finds the Euclidean distance from the returned point to another point - the centre of rotation of the swirl. This method was written solely to be called by "swirl_zonalmorph". </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">subset</td><td>A list of pixels to be passed to "local_cop" </td></tr>
    <tr><td class="paramname">centre</td><td>Point object representing the centre.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Double representing the Euclidean distance from the barycentre of the sub-region to the centre of rotation. </dd></dl>

</div>
</div>
<a id="abdc3d23cdcabbba67f726f350bf80513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc3d23cdcabbba67f726f350bf80513">&#9670;&nbsp;</a></span>local_dilation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::local_dilation </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs morphological dilation on an elliptical region on the image. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">centre</td><td>Point object defining the centre of the elliptical area to be modified </td></tr>
    <tr><td class="paramname">a</td><td>Integer minor axis </td></tr>
    <tr><td class="paramname">b</td><td>Integer major axis</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>{Picure object with the transformation applied.} </dd></dl>

</div>
</div>
<a id="ade2358613a2b65fca62dfc31844fb06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2358613a2b65fca62dfc31844fb06a">&#9670;&nbsp;</a></span>local_erosion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::local_erosion </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs morphological erosion on an elliptical region on the image. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">centre</td><td>Point object defining the centre of the elliptical area to be modified </td></tr>
    <tr><td class="paramname">a</td><td>Integer minor axis </td></tr>
    <tr><td class="paramname">b</td><td>Integer major axis</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Picure object with the transformation applied. </dd></dl>

</div>
</div>
<a id="a1f3c0a19d314e537fa02b32b753d1b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3c0a19d314e537fa02b32b753d1b2e">&#9670;&nbsp;</a></span>loss_function_xt_by_barycenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::loss_function_xt_by_barycenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>translated</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performing a rapid estimation of the translation parameter along x axis by comparing the two barycenters with squared error. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">translated</td><td>the shifted picture we are estimating shift param. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The translation parameterS tx and ty which minimize the error between the two pictures. </dd></dl>

</div>
</div>
<a id="ad9c35a3efdb131d758669d4ee6c97363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c35a3efdb131d758669d4ee6c97363">&#9670;&nbsp;</a></span>loss_function_xyt_by_barycenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point Picture::loss_function_xyt_by_barycenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>translated</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performing a rapid estimation of the translation parameters along x and y axis by comparing the two barycenters with squared error. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">translated</td><td>the shifted picture we are estimating shift param. return The integer translation parameter which minimize the error between the two pictures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af984b6b082be59e5034a0b370335acdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af984b6b082be59e5034a0b370335acdc">&#9670;&nbsp;</a></span>loss_function_xyt_by_barycenter_covariance_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point Picture::loss_function_xyt_by_barycenter_covariance_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>translated</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performing a rapid estimation of the translation parameters along x and y axis by comparing the two barycenters with 2nd loss function. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">translated</td><td>the shifted picture we are estimating shift param. return The integer translation parameterS which minimizes the error between the two pictures. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af89fa0248ccd43f99bef6efd52c49c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89fa0248ccd43f99bef6efd52c49c26">&#9670;&nbsp;</a></span>maximum_intensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::maximum_intensity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which return the maximum intensity of the image. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Maximum intensity of the image (float in [0,1]). </dd></dl>

</div>
</div>
<a id="a3596ef7e0ad76f05817c7f1add908fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3596ef7e0ad76f05817c7f1add908fc1">&#9670;&nbsp;</a></span>minimum_intensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::minimum_intensity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which return the minimum intensity of the image. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Minimum intensity of the image (float in [0,1]). </dd></dl>

</div>
</div>
<a id="a76f07f674b2ceaacdde38bb4b5a273bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f07f674b2ceaacdde38bb4b5a273bb">&#9670;&nbsp;</a></span>more_accurate_rotation_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::more_accurate_rotation_parameter </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>rotated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which allow us to accurate the rotation parameter with squared error. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>the angle approximated with estimation rotation functions </td></tr>
    <tr><td class="paramname">rotated</td><td>the rotated picture</td></tr>
  </table>
  </dd>
</dl>
<p>return The closest float to the rotation parameter between the two pictures </p>

</div>
</div>
<a id="aca3269976b9cc9a3d6aa536efeede017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3269976b9cc9a3d6aa536efeede017">&#9670;&nbsp;</a></span>morph_subsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; list&lt; Point &gt;, Dynamic, Dynamic &gt; Picture::morph_subsets </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subset_sidelen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>centre</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a square around the area on which the swirl transformation is being applied and divides it into grid squares. This was written solely to be called by the method "swirl_zonalmorph". </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>The radius of the circle on which the rotation is applied (half the side length of the square). </td></tr>
    <tr><td class="paramname">subset_sidelen</td><td>The number of subdivisions of the side of the square to make the grid squares and the centre of the region. </td></tr>
    <tr><td class="paramname">centre</td><td>The centre of rotation of the swirl effect being modelled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>A Matrix object (Eigen library) with lists of Point objects as entries. </dd></dl>

</div>
</div>
<a id="acaa72548de97134a61c589b56d1dad8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa72548de97134a61c589b56d1dad8b">&#9670;&nbsp;</a></span>nn_rotation_polar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::nn_rotation_polar </td>
          <td>(</td>
          <td class="paramtype">cv::Point &amp;&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method that performs rotation of the pixel co-ordinates using conversion to polar co-ordinates then assigns intensities using nearest-neighbour interpolation; assigning to the new pixel the intensity of the original pixel with minimal Euclidean distance from it. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">centre</td><td>The centre of rotation as a Point object. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle of rotation in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>A new <a class="el" href="classPicture.html">Picture</a> object with the rotated intensity values. </dd></dl>

</div>
</div>
<a id="acfad20390ce78d52fe6c58f23cc02419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfad20390ce78d52fe6c58f23cc02419">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a>&#160;</td>
          <td class="paramname"><em>to_substract</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator - is overloaded in order to give us the absolute error picture. If the result is a black picture then both pictures that were compared were the same. </p>
<p>return The absolute error picture. </p>

</div>
</div>
<a id="a2725aca45105195611b2926ee4426fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2725aca45105195611b2926ee4426fb3">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picture::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a>&#160;</td>
          <td class="paramname"><em>pic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff2108d7dbc3c831791dc3d730f37c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2108d7dbc3c831791dc3d730f37c4d">&#9670;&nbsp;</a></span>pressure_center_gauss_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point Picture::pressure_center_gauss_threshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac70683bd364d34047758d3ccf2f6178f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70683bd364d34047758d3ccf2f6178f">&#9670;&nbsp;</a></span>print_loss_function_x_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::print_loss_function_x_translation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>translated</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performing the Bruteforce estimation of the translation parameter along x axis with squared error. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">translated</td><td>the shifted picture we are estimating shift param. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The closest integer to the translation parameter which minimize the error between the two pictures. </dd></dl>

</div>
</div>
<a id="a483b15adb1fb60952a4b0d78b7032952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483b15adb1fb60952a4b0d78b7032952">&#9670;&nbsp;</a></span>print_loss_function_xy_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point Picture::print_loss_function_xy_translation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPicture.html">Picture</a> &amp;&#160;</td>
          <td class="paramname"><em>translated</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performing the Bruteforce estimation of the translations parameters along x and y axis with squared error (take approximatelly 10 min). </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">translated</td><td>the shifted picture we are estimating shift param. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The closest integer to the translation parameterS tx and ty which minimize the error between the two pictures. </dd></dl>

</div>
</div>
<a id="afca81009cad83739d2805e88726c6bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca81009cad83739d2805e88726c6bf0">&#9670;&nbsp;</a></span>print_picture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picture::print_picture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which print the <a class="el" href="classPicture.html">Picture</a>. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>NONE </dd></dl>

</div>
</div>
<a id="acbada1eca07f4dd639acf20211879106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbada1eca07f4dd639acf20211879106">&#9670;&nbsp;</a></span>print_pression_center_gauss_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picture::print_pression_center_gauss_threshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb0b7c2f2b64317c06dfba0e924fa470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0b7c2f2b64317c06dfba0e924fa470">&#9670;&nbsp;</a></span>put_barycenter_at_picture_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::put_barycenter_at_picture_center </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function translate the picture in order to put the barycenter of the picture at the center of the picture. </p>
<p>return New picture which have barycenter in the center </p>

</div>
</div>
<a id="a4e662e749180d0430107b9b2ff38a6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e662e749180d0430107b9b2ff38a6d5">&#9670;&nbsp;</a></span>rescale_color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picture::rescale_color </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that rescale every color such that the maximum intensity is 1 and the minimum intensity is 0. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The transformed <a class="el" href="classPicture.html">Picture</a> (type <a class="el" href="classPicture.html">Picture</a>). </dd></dl>

</div>
</div>
<a id="a4bf21e37ce0579362726801c0a827a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf21e37ce0579362726801c0a827a19">&#9670;&nbsp;</a></span>SAVE_PIC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picture::SAVE_PIC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that save the picture as a .png. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">name,the</td><td>string that will be used as a filename (the filename has to include the extension of the image). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>NONE </dd></dl>

</div>
</div>
<a id="a49fc98e02fccbbe8c303dfb4f74ab70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fc98e02fccbbe8c303dfb4f74ab70e">&#9670;&nbsp;</a></span>set_intensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picture::set_intensity </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>intensity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which set the intensity of the pixel (j,i). </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>of the coordinates (i,j) of the pixel. </td></tr>
    <tr><td class="paramname">j</td><td>of the coordinate (i,j) of the pixel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>NONE </dd></dl>

</div>
</div>
<a id="a386c685f55ac781fd27031dbb5559d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386c685f55ac781fd27031dbb5559d16">&#9670;&nbsp;</a></span>show_nbh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picture::show_nbh </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Point &gt;&#160;</td>
          <td class="paramname"><em>nbh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the elliptical region formed by the method "ellipse_nbh" as a white ellipse on the image. Could be used in general as a method to set any given set of pixels to white. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbh</td><td>vector of Point objects</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>A copy of the image with all of the points in the input vector set to intensity 1.0 </dd></dl>

</div>
</div>
<a id="aa888d4e8dee3200cc17b471626e65b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa888d4e8dee3200cc17b471626e65b88">&#9670;&nbsp;</a></span>sum_intensity_picture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Picture::sum_intensity_picture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which compute the sum of the pixels intensity of a picture. </p>
<p>return The pixel intensity sum </p>

</div>
</div>
<a id="a34d27af85dc851842fcff8f001fac54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d27af85dc851842fcff8f001fac54d">&#9670;&nbsp;</a></span>swirl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::swirl </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>twist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method that creates the swirl effect caused by rotating a finger under pressure in a similar way to the polar rotation functions except that in this case the angle is given as a function of the radial distance from the centre of rotation. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">centre</td><td>The centre of the rotation, a floating-point coefficient controlling the "amount" of swirl to be applied. </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the circle on which the swirl effect is to be localised.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>A new <a class="el" href="classPicture.html">Picture</a> object with the transformation applied. </dd></dl>

</div>
</div>
<a id="abb14ad715902c52f516c8c563ec8ddfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb14ad715902c52f516c8c563ec8ddfd">&#9670;&nbsp;</a></span>swirl_zonalmorph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::swirl_zonalmorph </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>twist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root_num_sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the swirl transform followed by localised morphological filtering depending on the relative position of the barycentre of each list of Point objects returned by the function "morph_subsets". </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">centre</td><td>Point object defining the centre of the rotation </td></tr>
    <tr><td class="paramname">twist</td><td>Double-precision parameter controlling the "strength" of the swirl effect, integer radius of the rotation. </td></tr>
    <tr><td class="paramname">root_num_sub</td><td>Integer square root of the desired number of grid squares.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd><a class="el" href="classPicture.html">Picture</a> object with the transformation applied. </dd></dl>

</div>
</div>
<a id="ac41f68bed9c7ddaf76e158dd1677d989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41f68bed9c7ddaf76e158dd1677d989">&#9670;&nbsp;</a></span>symmetry_wrt_x()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::symmetry_wrt_x </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which perform the symetry of the image along the X axis. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The transformed <a class="el" href="classPicture.html">Picture</a> (type <a class="el" href="classPicture.html">Picture</a>). </dd></dl>

</div>
</div>
<a id="aa496dc958945a3f5470f7f661bdd8ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa496dc958945a3f5470f7f661bdd8ecd">&#9670;&nbsp;</a></span>symmetry_wrt_y()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::symmetry_wrt_y </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which perform the symetry of the image along the Y axis. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">NONE</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The transformed <a class="el" href="classPicture.html">Picture</a> (type <a class="el" href="classPicture.html">Picture</a>). </dd></dl>

</div>
</div>
<a id="aaf2d01387798bfb803daaddc0ed61458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2d01387798bfb803daaddc0ed61458">&#9670;&nbsp;</a></span>transform_anisotropic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::transform_anisotropic </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that perform an anisotropic intensity transformation on the image using an elliptic distance given with a center, and two radius. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>he center that will be used for the anisotropic function. </td></tr>
    <tr><td class="paramname">a</td><td>the small radius of the ellipse. </td></tr>
    <tr><td class="paramname">b</td><td>the big radius of the ellipse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The transformed <a class="el" href="classPicture.html">Picture</a> </dd></dl>

</div>
</div>
<a id="ac46452d4d7564020ca40ceff61f3f7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46452d4d7564020ca40ceff61f3f7f7">&#9670;&nbsp;</a></span>transform_isotropic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::transform_isotropic </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that perform an isotropic intensity transformation on the image. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the center that will be used for the isotropic function (type: Point)). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The transformed <a class="el" href="classPicture.html">Picture</a>. </dd></dl>

</div>
</div>
<a id="a351efc5be98e393cee2711b97a017404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351efc5be98e393cee2711b97a017404">&#9670;&nbsp;</a></span>translation_opti_int_xy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::translation_opti_int_xy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which allow us to perform a fast translation with integer param. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the translation param along x axis </td></tr>
    <tr><td class="paramname">y</td><td>the translation param along y axis</td></tr>
  </table>
  </dd>
</dl>
<p>return The translated picture </p>

</div>
</div>
<a id="a8a3de826b7693f687b760d4ed8246f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3de826b7693f687b760d4ed8246f40">&#9670;&nbsp;</a></span>translation_x()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::translation_x </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coeff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which perform picture translation along x. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeff</td><td>translation param (must be integer) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The translated, along x axis, copied <a class="el" href="classPicture.html">Picture</a> </dd></dl>

</div>
</div>
<a id="a92edfcd1b92afc6fd9fa658bcb59f423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92edfcd1b92afc6fd9fa658bcb59f423">&#9670;&nbsp;</a></span>translation_y()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPicture.html">Picture</a> Picture::translation_y </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>coeff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which perform picture translation along y. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeff</td><td>the translation param </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>The translated, along y axis, copied <a class="el" href="classPicture.html">Picture</a> </dd></dl>

</div>
</div>
<a id="a9c6c25c65fa207b866898af6a7d191be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6c25c65fa207b866898af6a7d191be">&#9670;&nbsp;</a></span>weak_pressure_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; Point &gt; Picture::weak_pressure_area </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Point &gt;&#160;</td>
          <td class="paramname"><em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that generate a random area around an ellipse. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">border</td><td>a border around an ellipse. </td></tr>
    <tr><td class="paramname">center</td><td>The center of the ellipse. </td></tr>
    <tr><td class="paramname">a</td><td>the small radius of the ellipse. </td></tr>
    <tr><td class="paramname">b</td><td>the big radius of the ellipse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>A vector containing the points of the random area generated (type: vector&lt;Point&gt;) </dd></dl>

</div>
</div>
<a id="a99f69fc5bc1febbd64af2995989399fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f69fc5bc1febbd64af2995989399fc">&#9670;&nbsp;</a></span>weak_pressure_border()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; Point &gt; Picture::weak_pressure_border </td>
          <td>(</td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that generate a random border around an ellipse. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The center of the ellipse. </td></tr>
    <tr><td class="paramname">a</td><td>the small radius of the ellipse. </td></tr>
    <tr><td class="paramname">b</td><td>the big radius of the ellipse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>A vector containing the points of the random border generated (type: vector&lt;Point&gt;). </dd></dl>

</div>
</div>
<hr/>La documentation de cette classe a été générée à partir des fichiers suivants :<ul>
<li>/home/tristan/Bureau/projet_final/Project_Infra/src/<a class="el" href="Picture_8h_source.html">Picture.h</a></li>
<li>/home/tristan/Bureau/projet_final/Project_Infra/src/<a class="el" href="Part1_8cpp.html">Part1.cpp</a></li>
<li>/home/tristan/Bureau/projet_final/Project_Infra/src/<a class="el" href="Part3_8cpp.html">Part3.cpp</a></li>
<li>/home/tristan/Bureau/projet_final/Project_Infra/src/<a class="el" href="Picture_8cpp.html">Picture.cpp</a></li>
<li>/home/tristan/Bureau/projet_final/Project_Infra/src/<a class="el" href="Picture__Optimization_8cpp.html">Picture_Optimization.cpp</a></li>
<li>/home/tristan/Bureau/projet_final/Project_Infra/src/<a class="el" href="PictureRotations_8cpp.html">PictureRotations.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
